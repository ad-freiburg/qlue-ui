import * as d3 from 'd3';
import { sleep } from "../utils";
import { data } from "./data"
import type { QueryExecutionTree } from '../types/query_execution_tree';
import { renderQueryExecutionTree } from './tree';

export function replaceIRIs(text: string): string {
  const iriPattern = /<([^>]+)>/g;

  return text.replace(iriPattern, (_match, iri) => {
    return shortenIRI(iri);
  });
}

function shortenIRI(iri: string): string {
  const fragmentIndex = iri.indexOf('#');
  if (fragmentIndex !== -1) {
    return `<${iri.substring(fragmentIndex + 1)}>`;
  }

  const queryIndex = iri.indexOf('?');
  const pathPart = queryIndex !== -1 ? iri.substring(0, queryIndex) : iri;

  const segments = pathPart.split('/').filter(s => s.length > 0);

  return `<${segments.length > 0 ? segments[segments.length - 1] : ''}>`;
}

export function truncateText(text: string, width: number) {
  if (text.length > width) {
    return text.substring(0, width) + "â€¦";
  }
  return text
}

export const line = d3
  .line()
  .x(d => d[0])
  .y(d => d[1])
  .curve(d3.curveBasis);

export function setupWebSocket(urlStr: string, queryId: string): WebSocket {
  const url = new URL(urlStr);
  url.protocol = url.protocol === "https:" ? "wss:" : "ws:";
  url.pathname = url.pathname.replace(/\/$/, "") + `/watch/${queryId}`;
  return new WebSocket(url);
}



export async function simulateMessages(zoom_to) {
  sleep(2000);
  let index = 0;
  while (true) {

    const queryExecutionTree = data[index] as QueryExecutionTree;
    renderQueryExecutionTree(queryExecutionTree, zoom_to);
    await sleep(500);
    index = (index + 1) % data.length;
    // if (index == 99) break;
  }
}
